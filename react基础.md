<!--
 * @Description:react基础
 * @Date: 2024-04-30 10:49:06
 * @LastEditTime: 2024-04-30 11:16:09
 * @FilePath: \React\word\react基础.md
 * @Author: caokai
-->

### React 是什么

React是由Meta公司研发，是一个用于构建web和原生交互界面的库

### React 的优势

相较于传统基于DOM开发的优势

- 组件化的开发方式
- 不错的性能
  相较于其他前端框架的优势
- 丰富的生态
- 跨平台支持
  
### React的市场情况
  
  全球流行，大厂必备
  
### 使用create-react-app快速搭建开发环境
  
  create-react-app 是一个快速创建React开发环境的工具，底层由webpack构建，封装了配置细节，开箱即用
  执行命令：npx create-react-app react-basic
- npx Node.js工具命令，查找并执行后续的包命令
- create-react-app 核心包（固定写法），用于创建 React项目
- react-basic react项目名称（也可以自定义）
### JSX基础-概念和本质
#### 什么是jsx
概念：jsx是JavaScript和xml（html）的缩写，标识在js代码中 编写html模板结构，它是react中编写ui模板的方式

优势：

1.  html的声明式模板 写法
2.  js的可编程能力

#### jsx的本质
jsx并不是标准的js语法，它是js的语法扩展，浏览器本身不能识别，需要通过解析工具做解析之后才能在浏览器中运行

### jsx基础-高频场景

#### jsx中使用js表达式
在jsx中可以通过大括号语法{}识别JavaScript中的表达式，比如常见的变量、函数调用、方法调用等等

1. 使用引号传递字符串
2. 使用JavaScript变量
3. 函数调用和方法调用
4. 使用JavaScript对象

**注意：if语句、switch语句、变量声明属于语句，不是表达式，不能出现在{}中**

#### jsx实现列表渲染
语法：在jsx中可以使用原生js中的map方法便利渲染列表

#### jsx实现条件渲染
语法：在React中，可以通过逻辑与运算符&&、三元表达式（?:）实现基础的条件渲染

#### jsx中实现复杂条件渲染
需求:列表中需要更具文章状态适配三种情况，单图，三图，和无图三种模式
解决方案：自定义函数+if判断语句

### React 中事件绑定
#### React基础事件绑定
语法：on+事件名称={事件处理程序}，整体上遵循驼峰命名法

#### 使用事件对象参数 
语法：在时间回调函数中设置形参e

#### 传递自定义参数
语法： 事件绑定的位置改造成箭头函数的写法，在执行clickHandler实际处理业务函数的时候传递实参
**注意：不能直接写函数调用，这里事件绑定需要一个函数引用**

#### 同时传递事件对象和自定义参数
语法：在事件绑定的位置传递事件的实参e和自定义参数，clickHandler中声明形参，注意顺序对应

### React中的组件
#### 组件是什么
概念：一个组件就是用户界面的一部分，他可以有自己的逻辑和外观，组件之间可以互相嵌套，也可以服用多次
组件化开发可以让开发者开发变简单，像搭积木一样
#### React组件
在React中，一个组件就是首字母大写的函数，内部存放了组件的逻辑和视图ui，渲染组件只需要把组件当成标签书写即可
### useState基础使用
useState是一个React Hook（函数），它允许我们向组件添加一个状态变量，从而控制影响组件的渲染结果

本质：和普通js变量不同的是，状态变量一旦发生变化组件的试图ui也会跟着变化（数据驱动视图）

``` js
    const [count,setCount] = useState(0)
```
1. useState是一个函数 ，返回值是一个数组
2. 数组中的第一个参数是 状态变量，第二个参数是set函数用来修改状态变量
3. useState的参数将作为count的初始值

### 修改状态的规则
#### 状态不可变
在React中，状态被认为是只读的，我们应该始终替换它而不是修改它，直接修改状态不能引发视图更新
#### 修改对象状态
规则：对于对象类型的状态变量，应该始终传给set方法一个全新的对象来进行修改
### 组件的样式处理
#### React组件基础的样式控制有两种方式
1. 行内样式
2. class类名控制
#### classnames优化类名控制
classnames是一个简单的js库，可以非常方便的通过条件动态控制class类名的显示

### 表单受控绑定
#### 受控表单绑定
概念：使用React组件的状态控制表单的状态
1. 准备一个React状态值
2. 通过value属性绑定状态，通过onChange属性绑定状态同步的函数

### React获取DOM
#### React获取DOM
在React组件中获取/操作DOM，需要使用useRef钩子函数，分为两步：
1. 使用useRef创建ref对象，并与JSX绑定
2. 在DOM可用时，通过inputRef.current拿到DOM对象

### 组件通信
#### 理解组件通信
概念：组件通信就是组件之间的数据传递，根据组件嵌套关系的不同，有不同的通信方法

#### 父传子-基础实现
实现步骤
1. 父组件传递数据 - 在子组件标签上绑定属性
2. 子组件接收数据 - 子组件通过props参数接受数据

#### 父传子-props说明
1. props可传递任意的数据
   数字、字符串、布尔值、数组、对象、函数、jsx
2. props是只读对象
   子组件只能读取props中的数据，不能直接进行修改，父组件的数据只能由父组件修改

#### 父传子-特殊的prop children
场景：当我们把内容嵌套在子组件标签中时，父组件会自动在名为children的prop属性中接收该内容。

#### 父子组件通信-子传父
核心思路：在子组件中调用父组件中的函数并传递参数

#### 使用状态提升实现兄弟组件通信
实现思路：借助“状态提升”机制，通过父组件进行兄弟组件之间的数据传递
1. A组件先通过子传父的方式把数据传给父组件App
2. AApp 拿到数据后通过父传子的方式再传递给B组件

#### 使用Context机制跨层级组件通信
实现步骤：
1. 使用createContext方法船舰一个上下文对象Ctx
2. 在顶层组件（App）中通过Ctx.Provider组件提供数据
3. 在底层组件（B）中通过useContext狗子函数获取数据

### useEffect
#### useEffect的概念理解
useEffect是一个React Hook函数，用于在React组件中创建不是由事件引起二十由渲染本身引起的操作，比如发送ajax请求，更改dom等等

说明：上面的组件中没有发生任何的用户事件，组件渲染完毕之后就需要和服务器要数据，整个过程属于“只由渲染引起的操作”

#### useEffect的基础使用
需求：在组件渲染完毕之后，立刻从服务端获取频道列表数据并显示到页面中，
语法：
参数1：是一个函数，可以把它叫做副作用函数，在函数内部可以防止要执行的操作
参数2是一个数组（可选参），在数组里放置依赖项，不同依赖项会影响第一个参数函数的执行，当是一个空数组的时候，副作用函数只会在组件渲染完毕之后执行一次

#### useEffect 依赖项参数说明
useEffect副作用函数的执行时级存在多种情况，根据传入的依赖项不同，会有不同的执行表现，

| 依赖项         | 副作用函数执行时机i                 |
| -------------- | ----------------------------------- |
| 没有依赖项     | 组件初始渲染+组件更新时执行         |
| 空数组依赖项   | 只在初始渲染时执行一次              |
| 添加特定依赖项 | 组件初始渲染 + 特性依赖项变化时执行 |

#### useEffect ---清除副作用
在useEffect中编写的由渲染本身引起的对接组件外部的操作，社区也经常把它叫做副作用操作，比如在useEffect中开启了一个定时器，我们想在组件卸载的 时候把这个定时器 再清理掉，这个过程就是清除副作用。

说明：清除副作用的函数最常见的执行时机是在组件卸载时自动执行

### 自定义Hook函数的实现
#### 自定义Hook函数
概念：自定义Hook是以use打头的函数，通过自定义Hook函数可以用来实现逻辑的封装和复用

### ReactHooks使用规则 
使用规则：
1. 只能在组件中或者其他自定义Hook函数中调用
2. 只能在组件的顶层调用，不能嵌套再if、for、其他函数中

